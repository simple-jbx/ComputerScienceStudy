# 数据库

### 三/五范式

- 第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。
- 第二范式：确保表中的每列都和主键相关。
- 第三范式：确保每列都和主键列直接相关而不是间接相关。
- BC范式（BCNF）：消除主属性对键的部分和传递函数依赖。
- 第四范式：消除非平凡且非函数依赖的多值依赖。



<div align='center'>
    <img src='./imgs/Database/Database01.png' width='400px'>
    </br></br>规范化过程
</div>



<div align='center'>
    <img src='./imgs/Database/Database02.png' width='200px'>
    </br></br>各种范式之间的关系
</div>



### 主键和外键

|      | 主键                                       | 外键                                                 | 索引                               |
| ---- | ------------------------------------------ | ---------------------------------------------------- | ---------------------------------- |
| 定义 | 唯一标识一条记录，不能有重复的，不允许为空 | 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 | 该字段没有重复值，但可以有一个空值 |
| 作用 | 用来保证数据完整性                         | 用来和其他表建立联系用的                             | 是提高查询排序的速度               |
| 个数 | 主键只能有一个                             | 一个表可以有多个外键                                 | 一个表可以有多个索引               |



### 数据库的事务

#### 什么是数据库的事务

数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

#### 事务的四大特性（ACID）

- 原子性：指包含事务的操作要么全部执行成功，要么全部失败回滚。
- 一致性：指事务在执行前后状态是一致的。
- 隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。
- 持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。

#### 数据库并发一致性问题

当多个事务并发执行时，可能会出现以下问题：

- 脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。

- 不可重复度：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作，并提交了，导致事务A多次读取到的数据并不一致。

- 幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据的时候发现多了几条数据，和之前读取的数据不一致。

- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。

#### 数据库的隔离级别

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的

- 提交读：一个事务提交后，它的修改才能被其他事务看到

- 可重复度：在同一个事务中多次读取到的数据是一致的

- 串行化：需要加锁实现，会前置事务串行执行

事务的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 未提交读 | 允许   | 允许       | 允许   |
| 提交读   | 不允许 | 允许       | 允许   |
| 可重复读 | 不允许 | 不允许     | 允许   |
| 串行化   | 不允许 | 不允许     | 不允许 |

##### 隔离级别如何实现

事务的隔离机制主要是依靠锁机制和MVCC实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。

#### MVCC

MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。

### 索引

索引是对数据库表中的一列或者多列的值进行排序一种结构，使用索引可以快速访问数据表中的特定信息。

#### 索引优缺点

**优点**：

- 加快检索速度

- 将随机IO变为顺序IO（B+树的叶子结点是连接在一起的）

- 加快表与表之间的连接

**缺点**：

- 占用物理空间

- 创建和维护索引都需要花费时间（对数据进行增删改的时候都要维护索引）

#### 索引的数据结构

B+树、哈希表（B+树、哈希索引）。InnoDB引擎的索引类型有B+树、哈希索引，默认索引类型为B+树索引。

B+树索引

#### 索引的种类

- 主键索引：数据列不允许重复，不能为null，一个表只能有一个主键索引。

- 组合索引：由多个列值组成的索引。

- 唯一索引：数据列不允许重复，可以为null，索引列的值必须唯一，如果是组合索引，则列值的组合必须唯一。

- 全文索引：对文本的内容进行索引。

- 普通索引：基本的索引类型，可以为null。

#### B树和B+树的区别

#### 索引为什么使用B+树而不用B树

#### 聚簇索引和非聚簇索引

主要区别是**数据和索引是否分开存储**。

**聚簇索引：**将数据和索引放到一起存储，索引结构的叶子结点保留了数据行。

**非聚簇索引：**将数据和索引分开存储，索引叶子结点存储的是指向数据行的地址。

#### 索引的使用场景

- 对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描。
- 对于超大型的表，建立和维护索引的代价也会非常高，可以考虑分区。
- 增删改非常多的，查询比较少的没必要建立索引。
- 多个字段经常被查询的可以考虑联合索引。
- 字段多且字段值没有重复的时候考虑唯一索引。
- 字段多且有重复的时候考虑普通索引。

#### 如何对索引进行优化

- 索引列不能是表达式的一部分。
- 将区分度高的索引放在前面
- 尽量少使用select *

#### 创建与删除索引

#### 索引的设计原则

- 出现在where后面的列或者连接句子中指定的列，不会出现在where条件中的字段不适合创建索引。
- 索引列值的可能越多，索引效果越好（唯一性太差的字段不适合建立索引）。
- 尽量使用短索引，对于较长字符串进行索引时应该指定一个较短的前缀长度，较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。
- 尽量使用最左前缀。
- 不要过度使用索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。

- 较频繁作为查询条件的字段

- 更新太频繁的字段不适合创建索引

#### 索引在什么情况下会失效

- 条件中有 or。
- 索引列参与计算。
- 在索引的类型上进行数据类型的隐形转换
- 在索引中使用函数
- 在使用like查询时以%开头（模糊查询）
- 在索引上使用！、=、<>进行判断
- 索引字段上使用 is null/is not null判断时

# MySQL

## Explain详解

### id列

包含一个编号，标识select所属的行。如果语句中没有子查询或联合，则只有唯一的id(1)。

### select_type列

mysql会将select查询分为简单和复杂类型，复杂类型可分为三大类：简单子查询、派生表（在from子句中的子查询），以及union查询。

select_type列显示了对应行是简单还是复杂select。如果查询有任何复杂的子部分，则最外层部分标记为PRIMARY，其他部分标记如下：

- SUBQUERY
    - 包含在SELECT列表中的子查询中的SELECT（不在FROM子句中）标记为SUBQUERY。
- DERIVED
    - 包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中。服务器内部称其“派生表”，因为该临时表是从子查询中派生来的。
- UNION
    - 在UNION中的第二个和随后的SELECT被标记为UNION。如果UNION被FROM子句中的子查询包含，那么它的第一个SELECT会被标记为DERIVED。
- UNION RESULT
    - 用来从UNION的匿名临时表检索结果的SELECT被标记为UNION RESULT。

除了这些值，SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。DEPENDENT意味着SELECT依赖于外层查询中发现的数据；UNCACHEABLE意味着SELECT中的某些特性阻止结果被缓存于一个Item_cache中。

### table列

显示了对应查询id访问的表（或者表的别名）。MySQL选择的关联顺序不同于语句中所指定的顺序，MySQL的查询执行计划总是左侧深度优先树。

#### 派生表和联合

当FROM子句中有子查询或有UNION时，table列会变得复杂得多。在这些场景下，确实没有一个“表”可以参考到，因为MySQL创建的匿名临时表仅在查询执行过程中存在。

当在FROM子句中有子查询时，table列是`derivedN`的形式，其中N是子查询的id。这总是“向前引用”——换言之，N指向EXPLAIN输出中后面的一行。

当有UNION时，UNION RESULT的table列包含一个参与UNION的id列表。这总是“向后引用”，因为UNION RESULT出现在UNION中所有参与行之后。

### type列

访问类型（关联类型）。从上到下性能从最差到最优。

- ALL
    - 全表扫描（例外：查询里使用了LIMIT，或者在Extra列中显示“Using distinct/not exists”）。
- index
    - 与全表扫描一样，只是扫描的是索引。优点是避免了排序，缺点是要承担按索引次序读取整个表的开销（若是随机访问则开销会很大）。
    - Extra列using index表示覆盖索引，需要与index区别。
- range
    - 范围扫描，有限制的索引扫描。不用遍历全部索引。
- ref
    - 索引访问（索引查找），返回所有匹配某个单个值的行。
    - 它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。
    - 此类索引访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。把它叫做ref是因为索引要跟某个参考值相比较。这个参考值或者是一个常数，或者是来自多表查询前一个表里的结果值。
    - ref_or_null是ref之上的一个变体，它意味着MySQL必须在初次查找的结果里进行第二次查找以找出NULL条目。
- eq_ref
    - 最多只返回一条符合条件的记录。
    - 在MySQL使用主键或者唯一性索引查找时看到，它会将它们与某个参考值做比较。
- const, system
    - 对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。
- NULL
    - MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。

### possibIe_keys列

表示查询可以使用哪些索引。这个列表是在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。

### key列

MySQL 决定采用哪个索引来优化对该表的访问。如果该索引没有出现在possible_keys列中，那么MySQL选用它是出于另外的原因——例如，它可能选择了一个覆盖索引，哪怕没有WHERE子句。

### key_len列

MySQL在索引里使用的字节数（估计值，最大的可能长度，不是实际使用的值）。

### ref列

key列记录的索引中查找值所用的列或常量。

### rows列

为了找到所需的行而要读取的行数（估计值）。是MySQL为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。如果有内嵌语句的话，将每个内嵌语句所需检查的估计值相乘可粗略估算出整个查询会检查的行数。

### fiItered列

MySQL 5.1里新加进去的，在使用EXPLAIN EXTENDED时出现。它显示的是针对表里符合某个条件（WHERE子句或联接条件）的记录数的百分比所做的一个悲观估算。优化器只有在使用ALL、index、range和index_merge访问方法时才会用这一估算（在第3版书里写作的时候）。

### Extra列

- Using index
    - 覆盖索引，以避免访问表。
- Using where
    - 意味着MySQL服务器将在存储引擎检索行后再进行过滤。
- Using temporary
    - MySQL在对查询结果排序时会使用一个临时表。
- Using filesort
    - MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序算法，两种方式都可以在内存或磁盘上完成。
- Range checked for each record (index map: N)
    - 没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中素引的位图，并且是冗余的。

# References

1. https://mp.weixin.qq.com/s/olmqhogDIW1dE3_RwQ78Bg
1. [高性能MySQL：第3版]()
1. [什么是DDL与DML](https://blog.csdn.net/qq877507054/article/details/122311887)
1. [DDL和DML的含义与区别](https://blog.csdn.net/delightK/article/details/120948590)