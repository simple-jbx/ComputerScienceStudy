# 模拟

## [LeetCode 1583. 统计不开心的朋友](https://leetcode-cn.com/problems/count-unhappy-friends/)

# 图&树

## **拓扑排序**★★★★★

### [LeetCode 207.课程表](https://leetcode-cn.com/problems/course-schedule/)

节点分为三种状态，未搜索、搜索中、已搜索

```java
class Solution {
        int[] visited;
        boolean valid = true;
        List<List<Integer>> edges = new ArrayList<>();
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        visited = new int[numCourses];

        for (int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<Integer>());
        }

        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }

        for (int i = 0; i < numCourses; i++) {
            if(visited[i] == 0) {
                dfs(i);
            }
        }
        return valid ;
    }

    private void dfs(int n) {
        visited[n] = 1;

        for(int v : edges.get(n)) {
            if(visited[v] == 0) {
                dfs(v);
                if(!valid) {
                    return;
                }
            } else if(visited[v] == 1) {
                valid = false;
                return;
            }

        }
        visited[n] = 2;
    }
}
```

#### [LeetCode 210.课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)

```java
class Solution {

    List<List<Integer>> infos = new ArrayList<>();
    int[] visited;
    boolean vaild = true;
    List<Integer> ans = new ArrayList<>();
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        visited = new int[numCourses];

        for (int i = 0; i < numCourses; i++) {
            infos.add(new ArrayList<>());
        }

        for(int[] info : prerequisites) {
            infos.get(info[1]).add(info[0]);
        }

        for (int i = 0; i < numCourses; i++) {
            if(visited[i] == 0) {
                dfs(i);
            }
        }

        if(vaild) {
            return ans.stream().mapToInt(Integer::intValue).toArray();
        } else {
            return new int[0];
        }

    }

    private void dfs(int n) {
        visited[n] = 1;

        for(int v : infos.get(n)) {
            if(visited[v] == 0) {
                dfs(v);
                if(!vaild) {
                    return;
                }
            } else if(visited[v] == 1) {
                vaild = false;
                return;
            }
        }

        visited[n] = 2;
        ans.add(0, n);
    }
}
```

## 

## 最小生成树★★

#### [LeetCode 1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

Kruskal(并查集)：贪心选（最短）边



```java
class Solution {

    class Edge {
        int len, x, y;

        public Edge(int len, int x, int y) {
            this.len = len;
            this.x = x;
            this.y = y;
        }
    }

    class DisjointSetUnion {
        int[] f;
        int[] rank;
        int n;

        public DisjointSetUnion(int n) {
            this.n = n;
            this.rank = new int[n]; //加入秩（经验）优化，把小堆加到大堆中，去掉也可以
            Arrays.fill(this.rank, 1);
            this.f = new int[n];

            for (int i = 0; i < n; i++) {
                this.f[i] = i;
            }
        }

        //查找父节点（顺带更新）
        public int find(int x) {
            return f[x] == x ? x : (f[x] = find(f[x]));
        }

        //合并两个节点
        public boolean unionSet(int x, int y) {
            int fx = find(x), fy = find(y);

            if(fx == fy) {
                return false;
            }

            if(rank[fx] < rank[fy]) {
                int temp = fx;
                fx = fy;
                fy = temp;
            }

            rank[fx] += rank[fy];
            f[fy] = fx;
            return true;
        }
    }

    public int dist(int[][] points, int x, int y) {
        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
    }

    public int minCostConnectPoints(int[][] points) {

        int n = points.length;

        DisjointSetUnion dsu = new DisjointSetUnion(n);
        List<Edge> edges = new ArrayList<Edge>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                edges.add(new Edge(dist(points, i, j), i, j));
            }
        }

        //对边进行排序，方便后续选边 用堆也可以
        Collections.sort(edges, new Comparator<Edge>() {
            public int compare(Edge edge1, Edge edge2) {
                return edge1.len - edge2.len;
            }
        });

        int ret = 0, num = 1;

        for (Edge edge : edges) {
            int len = edge.len, x = edge.x, y = edge.y;
            //如果这条边上的两个点属于两个集合，则合并成功，将边的长度加入ret
            if(dsu.unionSet(x, y)) {
                ret += len;
                num++;

                if(num == n) {
                    break;
                }
            }
        }
        return ret;
    }
}
```

## 欧拉回路/欧拉通路

### Hierholzer 算法

Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：

从起点出发，进行深度优先搜索。

每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。

如果没有可移动的路径，则将所在节点加入到栈中，并返回。

当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。

不妨倒过来思考。我们注意到只有那个入度与出度差为 11 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。

对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。

这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。

#### [LeetCode 332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

```java
class Solution {
    Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();
    List<String> itinerary = new LinkedList<String>();

    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets) {
            String src = ticket.get(0), dst = ticket.get(1);
            if (!map.containsKey(src)) {
                map.put(src, new PriorityQueue<String>());
            }
            map.get(src).offer(dst);
        }
        dfs("JFK");
        Collections.reverse(itinerary);
        return itinerary;
    }

    public void dfs(String curr) {
        while (map.containsKey(curr) && map.get(curr).size() > 0) {
            String tmp = map.get(curr).poll();
            dfs(tmp);
        }
        itinerary.add(curr);
    }
}
```



#### [LeetCode 753. 破解保险箱](https://leetcode-cn.com/problems/cracking-the-safe/)



## 字典树★★

## 线段树

```java
class SegmentTree {
    
    int n;
    int[] tree;
    
    public SegmentTree(int[] nums) {
        int n = nums.length;
        tree = new int[n << 1];
        buildTree(nums);
    }
    
    private void buildTree(int[] nums) {
		//构造tree的n - 2n-1部分
		for (int i = n, j = 0; i < n << 1; i++, j++) {
			tree[i] = nums[j];
		}
		//构造tree的1-n-1部分
		for (int i = n - 1; i > 0; i--) {
			tree[i] = tree[i << 1] + tree[(i << 1) + 1];
		}
	}

	public void update(int i, int val) {
        i += n;//nums的索引与tree的索引相差n
        tree[i] = val;
        while (i > 0) {
            int left = i;
            int right = i;
            if (i & 1 == 0) {
                right = i + 1;//i为左孩子
            } 
            else {
                left = i - 1;//i为右孩子
            } 
            tree[i >> 1] = tree[left] + tree[right];
            i >>= 1;
        }
    }

    public int sumRange(int i, int j) {
        //nums的索引与tree的索引相差n
        i += n;
        j += n;
        int sum = 0;
        while (i <= j) {
            //目的是维持[i,j]我左右孩子，或者一个节点本身
            if (i & 1 == 1) {//i为右孩子
                sum += tree[i];
                i++;
            }
            
            if (j & 1 == 0) {//j为左孩子
                sum += tree[j];
                j--;
            }
            i >>= 1;
            j >>= 1;
        }
        return sum;
    }
}
```



# 数学

## 简单四则运算（带括号）

```java
public class Main {
    public static long calculate(String s) {
        List<String> sStr = spiltStr(s);
        Stack<Character> operators = new Stack<>();
        Stack<Long> operatornums = new Stack<>();

        int sLen = sStr.size();
        for (int i = 0; i < sLen; i++) {
            String str = sStr.get(i);
            if(isNumber(str)) {
                operatornums.push(Long.valueOf(str));
            } else {
                char c = str.charAt(0);
                if(operators.isEmpty() || c == '(') {
                    operators.push(c);
                } else if(c == ')') {
                    while (operators.peek() != '(') {
                        popAndCal(operators,operatornums);
                    }
                    operators.pop();
                } else if(c == '+' || c == '-') {
                    char topC = operators.peek();
                    while (topC == '+' || topC == '-' || topC == '*' || topC == '/') {
                        popAndCal(operators, operatornums);
                        topC = operators.isEmpty() ? ' ' : operators.peek();
                    }
                    operators.push(c);
                } else if(c == '*' || c == '/') {
                    char topC = operators.peek();
                    while (topC == '*' || topC == '/') {
                        popAndCal(operators, operatornums);
                        topC = operators.isEmpty() ? ' ' : operators.peek();
                    }
                    operators.push(c);
                }
            }
        }

        while (!operators.isEmpty()) {
            popAndCal(operators, operatornums);
        }

        return operatornums.pop();
    }

    public static boolean isNumber(String s) {
        return Character.isDigit(s.charAt(0));
    }

    public static List<String> spiltStr(String s) {
        List<String> res = new LinkedList<>();
        StringBuffer sb;

        int sLen = s.length();
        for (int i = 0; i < sLen; ) {
            if(i < sLen && s.charAt(i) == ' ') {
                i++;
                continue;
            } else if(!Character.isDigit(s.charAt(i))) {
                res.add(String.valueOf(s.charAt(i++)));
            } else {
                sb = new StringBuffer();
                while (i < sLen && Character.isDigit(s.charAt(i))) {
                    sb.append(s.charAt(i));
                    i++;
                }
                res.add(sb.toString());
            }
        }
        return res;
    }

    public static void popAndCal(Stack<Character> operators, Stack<Long> opernums) {
        long num2 = opernums.pop();
        long num1 = opernums.pop();
        char op = operators.pop();
        opernums.push(exe(num1, num2, op));
    }

    public static long exe(long num1, long num2, char op) {
        long res = 0L;
        switch (op) {
            case '+' :
                res = num1 + num2;
                break;
            case '-' :
                res = num1 - num2;
                break;
            case '*' :
                res = num1 * num2;
                break;
            case '/' :
                res = num1 / num2;
                break;
            default:
                break;
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(calculate(in.nextLine()));
    }
}
```



##  快速幂

```java
private static long quickPow(long x, long y, long mod) {
    long ans = 1L;
    while (y > 0) {
        if((y & 1) == 1) {
            ans *= x;
        }
        x *= x;
        x %= mod;
        ans %= mod;
        y >>= 1;
    }
        return ans;
}
```

##  矩阵快速幂

### [LeetCode 552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

```java
public long[][] pow(long[][] mat, int n) {
    long[][] ret = {{1, 0, 0, 0, 0, 0}}; //初始矩阵  相当于快速幂中的1
    while (n > 0) {
        if ((n & 1) == 1) {
            ret = multiply(ret, mat);
        }
        n >>= 1;
        mat = multiply(mat, mat);
    }
    return ret;
}

//矩阵相乘
public long[][] multiply(long[][] a, long[][] b) {
    int rows = a.length, columns = b[0].length, temp = b.length;
    long[][] c = new long[rows][columns];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            for (int k = 0; k < temp; k++) {
                c[i][j] += a[i][k] * b[k][j];
                c[i][j] %= MOD;
            }
        }
    }
    return c;
}
```





##  动态规划★★★★

找准状态转移方程

### [LeetCode 552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

### [LeetCode 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### [LeetCode 673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

### [LeetCode 1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

### [LeetCode 583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)



# 贪心★★

# 二分法★★★★★

# 二叉查找（搜索、排序，BST）树★★★★★



<div align='center'>
    <img src='./imgs/01.png' width=800px>
</div>

## [LeetCode 96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

假设有n个结点，值为1-n，问有所少中不同的二叉搜索树。

卡特兰数

<div align='center'>
    <img src='./imgs/02.png' width=800px>
</div>


```java
class Solution {
    public int numTrees(int n) {
        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }
}
```

## [LeetCode 108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

将有序数组转为高度平衡的二叉搜索树，三种方法，1：中序遍历，每次以(left + right) >> 1 位置处数字为根节点；2：中序遍历，每次选取(left + right + 1) >> 1处的数字作为根节点；3：中序遍历，每次选取(left + right ) >> 1 、(left + right + 1) >> 1任一位置处的数字作为根节点。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return createBST(nums, 0, nums.length - 1);
    }

    public TreeNode createBST(int[] nums, int left, int right) {
        if(left > right) {
            return null;
        }

        int mid = (left + right) >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = createBST(nums, left, mid - 1);
        root.right = createBST(nums, mid + 1, right);
        return root;
    }
}
```



# 并查集★★

# 分治法★★★



# 哈希表★★★★★

# 堆★★★

# 差分数组

## [LeetCode 1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)

# 扫描线