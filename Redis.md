# Redis概述

## 什么是Redis

高性能非关系型key-value数据库，底层使用C编写。数据存储在内存中，读写速度非常快，每秒可达10w+。

## Redis优缺点

### 优点

- 读写性能好，读11w+，写8w+。
- 支持数据持久化。
- 数据结构丰富，支持String、List、Set、Hash等结构。
- 支持事务，支持几个操作合并后原子性执行（lua脚本）。
- 支持主从复制，主机自动将数据同步到从机，进行读写分离。

### 缺点

- 数据存储在内存中，收内存大小限制。
- 不具备自动容错及恢复功能。

## Redis与Memcached的区别和共同点

### 相同点

- 读写性能都较高
- 都是基于内存，且通常被当做缓存
- 都有过期策略
- 都是基于C语言实现的

### 不同点

| 不同点       | Redis                                               | Memcached            |
| ------------ | --------------------------------------------------- | -------------------- |
| 是否支持复制 | 支持主从复制                                        | 不支持复制           |
| key长度      | 长度最大为2GB                                       | 长度最大为250B       |
| 数据类型     | String、Hash、List、Set、ZSet等                     | 仅支持key-value型    |
| 数据持久化   | 支持                                                | 不支持               |
| 网络IO模型   | 单线程多路IO复用（6.0后也支持多线程，网络IO多线程） | 多线程的非阻塞IO模式 |
| 集群         | 支持                                                | 不支持               |

## Redis为什么这么快

- 数据及其操作均在内存中
-  数据结构简单
- 使用多路IO复用技术
- 单线程实现，避免了线程切换（6.0之前）、锁等造成的性能开销

## Redis是单线程还是多线程

Redis6.0之前是单线程，之后是多线程。

单线程IO瓶颈通常在于CPU的IO，而使用Redis几乎不可能达到CPU IO的瓶颈，因此实际使用中的瓶颈在于内存和网络，并且使用单线程可以避免线程切换、锁等造成的性能开销。

Redis6.0之后引入多线程，主要为了解决网络IO读写的瓶颈，执行命令还是单线程的。

Redis默认没有开启多线程，开启需要修改配置文件，io-threads-do-reads yes。

## Redis数据类型

常见：String、Hash、Set、List、Zset

不常见：Bitmap、HyperLogLog、Geospatial

| 数据类型 | 可以存储的值                              | 可进行的操作                                                 | 应用场景                             |
| -------- | ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| String   | 字符串、整数、浮点数                      | 对整数或浮点数自增、自减                                     | 键值对缓存、常规计数：微博数、粉丝数 |
| List     | 列表（底层使用双向链表实现）              | 向列表两端添加元素，或者获取列表的某个片段                   | 存储文章ID列表、存储评论列表         |
| Set      | 无序集合（底层使用value为空的Hash来实现） | 增加/删除元素、获取集合中元素、取交集等                      | 共同好友、共同关注                   |
| ZSet     | 有序集合（底层使用Hash和跳表）            | 添加/获取/删除元素 根据分值范围或者成员获取元素 计算一个键的排名 | 去重、获取用户排名                   |
| Hash     | 包含key-value的无序散列表                 | 添加/获取/删除单个键值对 获取所有键值对 检查某个键值对是否存在 | 常用于存储对象                       |

**Bitmap**：以bit为单位的数组，数组中只能存储1 or 0，数组下标叫做偏移量。可实现统计功能，更省空间。

布隆过滤器（常用来解决缓存穿透问题）。

**HyperLogLog**：一种用于统计基数的数据集合类型，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。

**优点**是，在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定 的、并且是很小的。

**缺点**是 HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。

**Geospatial**：主要用于存储地理位置信息，常用于定位附近的人，打车距离的计算等。

## Redis数据结构

简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表等。

### 简单动态字符串

C里面的字符串以字符数组实现，不够灵活（以 \0结尾，使用前需要预先分配长度）。

### 链表

链表是列表的底层实现之一。

### 字典

又称符号表（symbol table）、关联数组（associativearray）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。

### 整数集合

整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

### 压缩列表（ziplist）

Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

### 对象

基于上面的基本数据结构创建了一个对象系统。包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

## 应用场景

1. 缓存：Redis基于内存，读写速度非常快，并且有键过期功能和键淘汰策略，可以作为缓存使用。
2. 排行榜：Redis提供的有序集合可以很方便地实现排行榜。
3. 分布式锁：Redis的setnx功能来实现分布式的锁。
4. 社交功能：共同好友、共同关注。
5. 计数器：通过String进行自增自减。
6. 消息队列：Redis提供了发布、订阅、阻塞队列等功能，可以实现一个简单的消息队列。

## Redis是单线程，如何提高CPU利用率

一个服务器上部署多个实例，把它们当做不同的服务器使用。

# Redis过期键删除策略

## 键的过期删除策略

常见的有惰性删除、定期删除、定时删除。

### 惰性删除

只有访问这个键时才会检查它是否过期，如果过期则清除。

优点：节省CPU资源

缺点：如果存在大量过期键，会浪费内存

### 定时删除

为每个设置过期时间的key都创造一个定时器，到了时间删除该键。

优点：可以定时清除过期键

缺点：占用CPU

### 定期删除

隔一段时间对一些键进行检查，删除其中过期的。惰性删除和定时删除的折中策略。

Redis中同时使用了惰性删除和定期删除两种。

## Redis内存淘汰机制

Redis基于内存，容量有限，有效的内存淘汰机制对Redis非常重要。

当Redis中数据超过最大允许内存后，就会触发Redis的内存淘汰策略。在Redis4.0之前有6中淘汰策略（前6个），Redis4.0之后又增加了两个（后两个）。

1. volatile-lru：当Redis内存不足时，会在设置了过期时间的键中使用LRU算法移除哪些最少使用的键。
2. volatile-ttl：从设置了过期时间的键中移除将要过期的。
3. volatile-random：从设置了过期时间的键中随机淘汰一些。
4. allkeys-lru：当内存空间不足时，根据LRU算法移除一些键。
5. allkeys-random：当内存空间不足时，随机移除某些键。
6. noeviction：当内存空间不足时，新的写入会报错。
7. volatile-lfu：从设置过期时间的键中移除一些最不经常使用的键。
8. allkeys-lfu：当内存不足时，从所有键中移除一些最不经常使用的键。

# Redis持久化

Redis基于内存，为了防止一些意外情况导致数据丢失，需要将数据持久化到磁盘上。

## Redis常见持久化机制以及优缺点

Redis提供了两种不同的持久化方式，一种是RDB，一种是AOF。

### RDF

Redis中默认的持久化方式，按照一定的时间间隔将内存中的数据以快照的形式保存到硬盘，恢复时将快照读取到内存中。具体操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

#### 优点

- 适合对大规模数据的恢复比AOF的启动效率高。
- 只有一个文件dump.rdb，方便持久化。
- 性能最大化，只需开始时fork出子进程，后续持久化由子进程完成，极大的避免了服务进程执行IO操作。

#### 缺点

- 数据安全性低，隔一段时间备份，如果Redis突然宕机有可能丢失数据。
- RDB通过fork子进程协助完成数据持久化工作，当数据集过大时候，有可能导致整个服务器停顿一段时间。

### AOF

以日志的形式记录服务器所处理的每一个写、删除操作，不记录读操作，以文本的方式记录，可以打开文件看到详细的操作记录。

#### 优点

- 更高的安全性，提供了3中同步策略，分别是每秒同步、每修改同步和不同步。
- 对日志文件写入采用append方式，写入过程即使出现宕机，也不会破坏日志文件中已经存在的内容。
- AOF包含一个格式清晰、易于理解的日志文件用于记录修改所有的修改操作，可以通过该文件完成数据的重建。

#### 缺点

- 同等数据量的条件下，AOF文件占用空间通常大于RDB文件。恢复大数据集时的速度低于RDB。
- AOF选择同步策略不同，效率也不同，AOF总体运行效率往往会慢与RDB。

